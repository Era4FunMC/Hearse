From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: BuildTools <unconfigured@null.spigotmc.org>
Date: Wed, 4 Jan 2023 15:19:31 +0800
Subject: [PATCH] Pathfinding Fixes


diff --git a/src/main/java/co/m2ek4u/aoame/CallbackExecutor.java b/src/main/java/co/m2ek4u/aoame/CallbackExecutor.java
index b861405a7626ba8fa677c455bf6507253b33c157..338fb59c86c552a75903dc74a79052a6eb5449ef 100644
--- a/src/main/java/co/m2ek4u/aoame/CallbackExecutor.java
+++ b/src/main/java/co/m2ek4u/aoame/CallbackExecutor.java
@@ -9,6 +9,7 @@ import java.util.concurrent.locks.LockSupport;
 public class CallbackExecutor extends ThreadPoolExecutor {
     private final AtomicBoolean isSubmittingStarted = new AtomicBoolean(false);
     private final Queue<TaskEntry> submittedTasks = new ConcurrentLinkedDeque<>();
+    private final Queue<Runnable> cleanTasks = new ConcurrentLinkedQueue<>();
 
     public CallbackExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, @NotNull TimeUnit unit, @NotNull BlockingQueue<Runnable> workQueue) {
         super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
@@ -26,6 +27,10 @@ public class CallbackExecutor extends ThreadPoolExecutor {
         super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
     }
 
+    public void submitCleanTask(Runnable task){
+        this.cleanTasks.add(task);
+    }
+
     public void startSubmitting(){
         if (this.isSubmittingStarted.get()){
             throw new IllegalStateException();
@@ -64,6 +69,12 @@ public class CallbackExecutor extends ThreadPoolExecutor {
                 LockSupport.parkNanos(this,1);
             }
         }
+        Runnable cleanTask;
+        while ((cleanTask = this.cleanTasks.poll())!=null){
+            try {
+                cleanTask.run();
+            }catch (Exception e){e.printStackTrace();}
+        }
     }
 
     private static class TaskEntry{
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/BinaryHeap.java b/src/main/java/net/minecraft/world/level/pathfinder/BinaryHeap.java
index 27b9cefc172b391824ead382a712b8b9b1ddfe45..c949325dc9b21d8a75ee639210911c61616949c8 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/BinaryHeap.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/BinaryHeap.java
@@ -4,10 +4,8 @@ public class BinaryHeap {
     private Node[] heap = new Node[128];
     private int size;
 
-    public Node insert(Node node) {
-        if (node.heapIdx >= 0) {
-            throw new IllegalStateException("OW KNOWS!");
-        } else {
+    public synchronized Node insert(Node node) {
+        if (node.heapIdx < 0) {
             if (this.size == this.heap.length) {
                 Node[] nodes = new Node[this.size << 1];
                 System.arraycopy(this.heap, 0, nodes, 0, this.size);
@@ -17,19 +15,19 @@ public class BinaryHeap {
             this.heap[this.size] = node;
             node.heapIdx = this.size;
             this.upHeap(this.size++);
-            return node;
         }
+        return node;
     }
 
-    public void clear() {
+    public synchronized void clear() {
         this.size = 0;
     }
 
-    public Node peek() {
+    public synchronized Node peek() {
         return this.heap[0];
     }
 
-    public Node pop() {
+    public synchronized Node pop() {
         Node node = this.heap[0];
         this.heap[0] = this.heap[--this.size];
         this.heap[this.size] = null;
@@ -41,7 +39,7 @@ public class BinaryHeap {
         return node;
     }
 
-    public void remove(Node node) {
+    public synchronized void remove(Node node) {
         this.heap[node.heapIdx] = this.heap[--this.size];
         this.heap[this.size] = null;
         if (this.size > node.heapIdx) {
@@ -55,7 +53,7 @@ public class BinaryHeap {
         node.heapIdx = -1;
     }
 
-    public void changeCost(Node node, float weight) {
+    public synchronized void changeCost(Node node, float weight) {
         float f = node.f;
         node.f = weight;
         if (weight < f) {
@@ -66,7 +64,7 @@ public class BinaryHeap {
 
     }
 
-    public int size() {
+    public synchronized int size() {
         return this.size;
     }
 
@@ -135,11 +133,11 @@ public class BinaryHeap {
         node.heapIdx = index;
     }
 
-    public boolean isEmpty() {
+    public synchronized boolean isEmpty() {
         return this.size == 0;
     }
 
-    public Node[] getHeap() {
+    public synchronized Node[] getHeap() {
         Node[] nodes = new Node[this.size()];
         System.arraycopy(this.heap, 0, nodes, 0, this.size());
         return nodes;
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/FlyNodeEvaluator.java b/src/main/java/net/minecraft/world/level/pathfinder/FlyNodeEvaluator.java
index b0bae04ab5a93dd4cf1eeeb02bed1e508e1f2913..d427735eff0056c171591709829d0bb76f7bb6f3 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/FlyNodeEvaluator.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/FlyNodeEvaluator.java
@@ -1,6 +1,7 @@
 package net.minecraft.world.level.pathfinder;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import java.util.EnumSet;
 import java.util.List;
@@ -15,7 +16,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.AABB;
 
 public class FlyNodeEvaluator extends WalkNodeEvaluator {
-    private final Long2ObjectMap<BlockPathTypes> pathTypeByPosCache = new Long2ObjectOpenHashMap<>();
+    private final Long2ObjectMap<BlockPathTypes> pathTypeByPosCache = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>());
     private static final float SMALL_MOB_INFLATED_START_NODE_BOUNDING_BOX = 1.5F;
     private static final int MAX_START_NODE_CANDIDATES = 10;
 
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/NodeEvaluator.java b/src/main/java/net/minecraft/world/level/pathfinder/NodeEvaluator.java
index a8a2594b8f5b3ebf6a1f918c7d822ad35b051b17..0aeff915b0518f64d291b6a4a538e0cd183535c5 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/NodeEvaluator.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/NodeEvaluator.java
@@ -1,8 +1,10 @@
 package net.minecraft.world.level.pathfinder;
 
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import net.minecraft.core.BlockPos;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.BlockGetter;
@@ -11,7 +13,7 @@ import net.minecraft.world.level.PathNavigationRegion;
 public abstract class NodeEvaluator {
     protected PathNavigationRegion level;
     protected Mob mob;
-    protected final Int2ObjectMap<Node> nodes = new Int2ObjectOpenHashMap<>();
+    protected final Int2ObjectMap<Node> nodes = Int2ObjectMaps.synchronize(new Int2ObjectOpenHashMap<>());
     protected int entityWidth;
     protected int entityHeight;
     protected int entityDepth;
@@ -30,8 +32,10 @@ public abstract class NodeEvaluator {
     }
 
     public void done() {
-        this.level = null;
-        this.mob = null;
+        MinecraftServer.getServer().asyncExecutor.submitCleanTask(()->{
+            this.level = null;
+            this.mob = null;
+        });
     }
 
     protected Node getNode(BlockPos pos) {
@@ -39,9 +43,7 @@ public abstract class NodeEvaluator {
     }
 
     protected Node getNode(int x, int y, int z) {
-        return this.nodes.computeIfAbsent(Node.createHash(x, y, z), (l) -> {
-            return new Node(x, y, z);
-        });
+        return this.nodes.computeIfAbsent(Node.createHash(x, y, z), (l) -> new Node(x, y, z));
     }
 
     public abstract Node getStart();
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/Path.java b/src/main/java/net/minecraft/world/level/pathfinder/Path.java
index 2a335f277bd0e4b8ad0f60d8226eb8aaa80a871f..96765e6fe34ed5bce3ebe9859714d9bd805d7d22 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/Path.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/Path.java
@@ -21,7 +21,7 @@ public class Path {
     private final BlockPos target;
     private final float distToTarget;
     private final boolean reached;
-    public boolean hasNext() { return getNextNodeIndex() < this.nodes.size(); } // Paper
+    public synchronized boolean hasNext() { return getNextNodeIndex() < this.nodes.size(); } // Paper
 
     public Path(List<Node> nodes, BlockPos target, boolean reachesTarget) {
         this.nodes = nodes;
@@ -30,51 +30,51 @@ public class Path {
         this.reached = reachesTarget;
     }
 
-    public void advance() {
+    public synchronized void advance() {
         ++this.nextNodeIndex;
     }
 
-    public boolean notStarted() {
+    public synchronized boolean notStarted() {
         return this.nextNodeIndex <= 0;
     }
 
-    public boolean isDone() {
+    public synchronized boolean isDone() {
         return this.nextNodeIndex >= this.nodes.size();
     }
 
     @Nullable
-    public Node getEndNode() {
+    public synchronized Node getEndNode() {
         return !this.nodes.isEmpty() ? this.nodes.get(this.nodes.size() - 1) : null;
     }
 
-    public Node getNode(int index) {
+    public synchronized Node getNode(int index) {
         return this.nodes.get(index);
     }
 
-    public void truncateNodes(int length) {
+    public synchronized void truncateNodes(int length) {
         if (this.nodes.size() > length) {
             this.nodes.subList(length, this.nodes.size()).clear();
         }
 
     }
 
-    public void replaceNode(int index, Node node) {
+    public synchronized void replaceNode(int index, Node node) {
         this.nodes.set(index, node);
     }
 
-    public int getNodeCount() {
+    public synchronized int getNodeCount() {
         return this.nodes.size();
     }
 
-    public int getNextNodeIndex() {
+    public synchronized int getNextNodeIndex() {
         return this.nextNodeIndex;
     }
 
-    public void setNextNodeIndex(int nodeIndex) {
+    public synchronized void setNextNodeIndex(int nodeIndex) {
         this.nextNodeIndex = nodeIndex;
     }
 
-    public Vec3 getEntityPosAtNode(Entity entity, int index) {
+    public synchronized Vec3 getEntityPosAtNode(Entity entity, int index) {
         Node node = this.nodes.get(index);
         double d = (double)node.x + (double)((int)(entity.getBbWidth() + 1.0F)) * 0.5D;
         double e = (double)node.y;
@@ -82,28 +82,28 @@ public class Path {
         return new Vec3(d, e, f);
     }
 
-    public BlockPos getNodePos(int index) {
+    public synchronized BlockPos getNodePos(int index) {
         return this.nodes.get(index).asBlockPos();
     }
 
-    public Vec3 getNextEntityPos(Entity entity) {
+    public synchronized Vec3 getNextEntityPos(Entity entity) {
         return this.getEntityPosAtNode(entity, this.nextNodeIndex);
     }
 
-    public BlockPos getNextNodePos() {
+    public synchronized BlockPos getNextNodePos() {
         return this.nodes.get(this.nextNodeIndex).asBlockPos();
     }
 
-    public Node getNextNode() {
+    public synchronized Node getNextNode() {
         return this.nodes.get(this.nextNodeIndex);
     }
 
     @Nullable
-    public Node getPreviousNode() {
+    public synchronized Node getPreviousNode() {
         return this.nextNodeIndex > 0 ? this.nodes.get(this.nextNodeIndex - 1) : null;
     }
 
-    public boolean sameAs(@Nullable Path o) {
+    public synchronized boolean sameAs(@Nullable Path o) {
         if (o == null) {
             return false;
         } else if (o.nodes.size() != this.nodes.size()) {
@@ -121,7 +121,7 @@ public class Path {
         }
     }
 
-    public boolean canReach() {
+    public synchronized boolean canReach() {
         return this.reached;
     }
 
@@ -133,16 +133,16 @@ public class Path {
     }
 
     @VisibleForDebug
-    public Node[] getOpenSet() {
+    public synchronized Node[] getOpenSet() {
         return this.openSet;
     }
 
     @VisibleForDebug
-    public Node[] getClosedSet() {
+    public synchronized Node[] getClosedSet() {
         return this.closedSet;
     }
 
-    public void writeToStream(FriendlyByteBuf buffer) {
+    public synchronized void writeToStream(FriendlyByteBuf buffer) {
         if (this.targetNodes != null && !this.targetNodes.isEmpty()) {
             buffer.writeBoolean(this.reached);
             buffer.writeInt(this.nextNodeIndex);
@@ -213,15 +213,15 @@ public class Path {
     }
 
     @Override
-    public String toString() {
+    public synchronized String toString() {
         return "Path(length=" + this.nodes.size() + ")";
     }
 
-    public BlockPos getTarget() {
+    public synchronized BlockPos getTarget() {
         return this.target;
     }
 
-    public float getDistToTarget() {
+    public synchronized float getDistToTarget() {
         return this.distToTarget;
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java b/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
index a8af51a25b0f99c3a64d9150fdfcd6b818aa7581..0f49ddf4796977a234e35b1a8d03a59642e18763 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
@@ -8,10 +8,13 @@ import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.profiling.metrics.MetricCategory;
 import net.minecraft.world.entity.Mob;
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java b/src/main/java/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java
index 6084631b5b502279b84f190dc62fc76b770e368e..f526adbd31e65fc74af48f6137d293a7a7ceafbb 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java
@@ -2,6 +2,7 @@ package net.minecraft.world.level.pathfinder;
 
 import com.google.common.collect.Maps;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import java.util.Map;
 import javax.annotation.Nullable;
@@ -17,7 +18,7 @@ import net.minecraft.world.level.material.FluidState;
 
 public class SwimNodeEvaluator extends NodeEvaluator {
     private final boolean allowBreaching;
-    private final Long2ObjectMap<BlockPathTypes> pathTypesByPosCache = new Long2ObjectOpenHashMap<>();
+    private final Long2ObjectMap<BlockPathTypes> pathTypesByPosCache = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>());
 
     public SwimNodeEvaluator(boolean canJumpOutOfWater) {
         this.allowBreaching = canJumpOutOfWater;
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java b/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
index 365c3d01a59d117ee9f238b1c1ded645d6b758d3..34fbabc696c0e82b907f4bf7e63b6b92ed89e7e1 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
@@ -1,8 +1,10 @@
 package net.minecraft.world.level.pathfinder;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
+import it.unimi.dsi.fastutil.objects.Object2BooleanMaps;
 import it.unimi.dsi.fastutil.objects.Object2BooleanOpenHashMap;
 import java.util.EnumSet;
 import javax.annotation.Nullable;
@@ -33,8 +35,8 @@ public class WalkNodeEvaluator extends NodeEvaluator {
     public static final double SPACE_BETWEEN_WALL_POSTS = 0.5D;
     private static final double DEFAULT_MOB_JUMP_HEIGHT = 1.125D;
     protected float oldWaterCost;
-    private final Long2ObjectMap<BlockPathTypes> pathTypesByPosCache = new Long2ObjectOpenHashMap<>();
-    private final Object2BooleanMap<AABB> collisionCache = new Object2BooleanOpenHashMap<>();
+    private final Long2ObjectMap<BlockPathTypes> pathTypesByPosCache = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>());
+    private final Object2BooleanMap<AABB> collisionCache = Object2BooleanMaps.synchronize(new Object2BooleanOpenHashMap<>());
 
     @Override
     public void prepare(PathNavigationRegion cachedWorld, Mob entity) {
