From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: wangxyper <wangxyper@163.com>
Date: Wed, 4 Jan 2023 21:40:19 +0800
Subject: [PATCH] Add clean task to fix some error


diff --git a/src/main/java/co/m2ek4u/aoame/CallbackExecutor.java b/src/main/java/co/m2ek4u/aoame/CallbackExecutor.java
index b861405a7626ba8fa677c455bf6507253b33c157..338fb59c86c552a75903dc74a79052a6eb5449ef 100644
--- a/src/main/java/co/m2ek4u/aoame/CallbackExecutor.java
+++ b/src/main/java/co/m2ek4u/aoame/CallbackExecutor.java
@@ -9,6 +9,7 @@ import java.util.concurrent.locks.LockSupport;
 public class CallbackExecutor extends ThreadPoolExecutor {
     private final AtomicBoolean isSubmittingStarted = new AtomicBoolean(false);
     private final Queue<TaskEntry> submittedTasks = new ConcurrentLinkedDeque<>();
+    private final Queue<Runnable> cleanTasks = new ConcurrentLinkedQueue<>();
 
     public CallbackExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, @NotNull TimeUnit unit, @NotNull BlockingQueue<Runnable> workQueue) {
         super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
@@ -26,6 +27,10 @@ public class CallbackExecutor extends ThreadPoolExecutor {
         super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
     }
 
+    public void submitCleanTask(Runnable task){
+        this.cleanTasks.add(task);
+    }
+
     public void startSubmitting(){
         if (this.isSubmittingStarted.get()){
             throw new IllegalStateException();
@@ -64,6 +69,12 @@ public class CallbackExecutor extends ThreadPoolExecutor {
                 LockSupport.parkNanos(this,1);
             }
         }
+        Runnable cleanTask;
+        while ((cleanTask = this.cleanTasks.poll())!=null){
+            try {
+                cleanTask.run();
+            }catch (Exception e){e.printStackTrace();}
+        }
     }
 
     private static class TaskEntry{
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java b/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
index 919f8c1aa52aa8c468427e850d1d4764a915320f..1d86630f773cd47853279f8d09ff5cb6ba87ff60 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
@@ -14,6 +14,7 @@ import java.util.function.Function;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.profiling.metrics.MetricCategory;
 import net.minecraft.world.entity.Mob;
@@ -22,7 +23,6 @@ import net.minecraft.world.level.PathNavigationRegion;
 public class PathFinder {
     private static final float FUDGING = 1.5F;
     private final Node[] neighbors = new Node[32];
-    private final ReadWriteLock evaluatorLock = new ReentrantReadWriteLock();
     private final int maxVisitedNodes;
     public final NodeEvaluator nodeEvaluator;
     private static final boolean DEBUG = false;
@@ -36,40 +36,21 @@ public class PathFinder {
     @Nullable
     public Path findPath(PathNavigationRegion world, Mob mob, Set<BlockPos> positions, float followRange, int distance, float rangeMultiplier) {
         this.openSet.clear();
-        this.evaluatorLock.writeLock().lock();
-        try {
-            this.nodeEvaluator.prepare(world, mob);
-        }finally {
-            this.evaluatorLock.writeLock().unlock();
-        }
-        Node node;
-        this.evaluatorLock.readLock().lock();
-        try{
-            node = this.nodeEvaluator.getStart();
-        }finally {
-            this.evaluatorLock.readLock().unlock();
-        }
+        this.nodeEvaluator.prepare(world, mob);
+        Node node = this.nodeEvaluator.getStart();
         if (node == null) {
             return null;
         } else {
             // Paper start - remove streams - and optimize collection
             List<Map.Entry<Target, BlockPos>> map = Lists.newArrayList();
-            this.evaluatorLock.readLock().lock();
-            try {
-                for (BlockPos pos : positions) {
-                    map.add(new java.util.AbstractMap.SimpleEntry<>(this.nodeEvaluator.getGoal(pos.getX(), pos.getY(), pos.getZ()), pos));
-                }
-            }finally {
-                this.evaluatorLock.readLock().unlock();
+            for (BlockPos pos : positions) {
+                map.add(new java.util.AbstractMap.SimpleEntry<>(this.nodeEvaluator.getGoal(pos.getX(), pos.getY(), pos.getZ()), pos));
             }
             // Paper end
             Path path = this.findPath(world.getProfiler(), node, map, followRange, distance, rangeMultiplier);
-            this.evaluatorLock.writeLock().lock();
-            try {
+            MinecraftServer.getServer().asyncExecutor.submitCleanTask(()->{
                 this.nodeEvaluator.done();
-            }finally {
-                this.evaluatorLock.writeLock().unlock();;
-            }
+            });
             return path;
         }
     }
@@ -115,13 +96,7 @@ public class PathFinder {
             }
 
             if (!(node.distanceTo(startNode) >= followRange)) {
-                int k;
-                this.evaluatorLock.readLock().lock();
-                try {
-                    k = this.nodeEvaluator.getNeighbors(this.neighbors, node);
-                }finally {
-                    this.evaluatorLock.readLock().unlock();
-                }
+                int k = this.nodeEvaluator.getNeighbors(this.neighbors, node);
 
                 for(int l = 0; l < k; ++l) {
                     Node node2 = this.neighbors[l];
