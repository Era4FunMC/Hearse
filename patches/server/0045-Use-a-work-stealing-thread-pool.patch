From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: wangxyper <wangxyper@163.com>
Date: Sun, 5 Feb 2023 19:49:22 +0800
Subject: [PATCH] Use a work stealing thread pool


diff --git a/src/main/java/co/earthme/hearse/concurrent/WorkStealingThreadPool.java b/src/main/java/co/earthme/hearse/concurrent/WorkStealingThreadPool.java
new file mode 100644
index 0000000000000000000000000000000000000000..42d63f105e35e622517378f07aa75e1951d620c5
--- /dev/null
+++ b/src/main/java/co/earthme/hearse/concurrent/WorkStealingThreadPool.java
@@ -0,0 +1,244 @@
+package co.earthme.hearse.concurrent;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+import java.util.concurrent.locks.*;
+
+public class WorkStealingThreadPool{
+    private final Executor packaged = new PackagedExecutor(this);
+    private final List<WorkerThread> workers = new ArrayList<>();
+    private final StampedLock workersLock = new StampedLock();
+    private int lastPostedPos = 0;
+    private final WorkerThreadFactory factory;
+
+    public WorkStealingThreadPool(int nThreads, WorkerThreadFactory factory){
+        this.factory = factory;
+        this.runWorkers(nThreads);
+    }
+
+    private void sendStopToAll(){
+        final long stamp = this.workersLock.readLock();
+        try {
+            for (WorkerThread workerThread : this.workers){
+                workerThread.sendStop();
+            }
+        }finally {
+            this.workersLock.unlockRead(stamp);
+        }
+    }
+
+    @NotNull
+    public Executor getPackaged() {
+        return this.packaged;
+    }
+
+    private void runWorkers(int threadCount){
+        for (int i = 0; i < threadCount; i++) {
+            final WorkerThread workerThread = new WorkerThread();
+            final long stamp = this.workersLock.writeLock();
+            try {
+                this.workers.add(workerThread);
+            }finally {
+                this.workersLock.unlockWrite(stamp);
+            }
+            workerThread.start();
+        }
+    }
+
+    public void awaitTasks(){
+        final long stamp = this.workersLock.readLock();
+        try {
+            for (WorkerThread workerThread : this.workers){
+                workerThread.awaitTasks();
+            }
+        }finally {
+            this.workersLock.unlockRead(stamp);
+        }
+    }
+
+    public void postTask(@NotNull Runnable task){
+        long stamp = this.workersLock.tryOptimisticRead();
+        if (this.workersLock.validate(stamp)){
+            int workerIndex;
+            synchronized (this.workers){
+                if (this.lastPostedPos+1 >= this.workers.size()){
+                    this.lastPostedPos = 0;
+                }
+                workerIndex = this.lastPostedPos++;
+            }
+            final WorkerThread workerThread = this.workers.get(workerIndex);
+            workerThread.postRunnable(task);
+            return;
+        }
+        stamp = this.workersLock.readLock();
+        try {
+            int workerIndex;
+            synchronized (this.workers){
+                if (this.lastPostedPos+1 >= this.workers.size()){
+                    this.lastPostedPos = 0;
+                }
+                workerIndex = this.lastPostedPos++;
+            }
+            final WorkerThread workerThread = this.workers.get(workerIndex);
+            workerThread.postRunnable(task);
+        }finally {
+            this.workersLock.unlockRead(stamp);
+        }
+    }
+
+    public <T> Future<T> postTask(@NotNull Callable<T> task){
+        final FutureTask<T> newTask = new FutureTask<>(task);
+        this.postTask(newTask);
+        return newTask;
+    }
+
+    private class WorkerThread implements Runnable {
+        private final Deque<Runnable> tasks = new ArrayDeque<>();
+        private final ReadWriteLock taskLock = new ReentrantReadWriteLock();
+        private final AtomicBoolean runningTask = new AtomicBoolean();
+        private final Thread worker = WorkStealingThreadPool.this.factory.getNewThread(this);
+
+        private volatile boolean shouldRun = false;
+        private volatile boolean running = false;
+
+
+        public void postRunnable(@NotNull Runnable task){
+            this.taskLock.writeLock().lock();
+            try {
+                this.tasks.add(task);
+            }finally {
+                this.taskLock.writeLock().unlock();
+            }
+        }
+
+        public void sendStop(){
+            this.shouldRun = false;
+            LockSupport.unpark(this.worker);
+        }
+
+        public void awaitTerminate(){
+            while (this.running){
+                LockSupport.parkNanos(100000);
+            }
+        }
+
+        public void awaitTasks(){
+            while (this.runningTask.get()){
+                LockSupport.parkNanos(100000);
+            }
+        }
+
+        @Override
+        public void run(){
+            Runnable curTask;
+            Runnable stole;
+            while (this.shouldRun || !this.tasks.isEmpty()){
+                if ((curTask = this.pollTask(false)) != null){
+                    this.runningTask.set(true);
+                    try {
+                        curTask.run();
+                    }catch (Exception e){
+                        e.printStackTrace();
+                    }finally {
+                        this.runningTask.set(false);
+                    }
+                    continue;
+                }
+
+                if ((stole = this.steal()) != null){
+                    try {
+                        stole.run();
+                    }catch (Exception e){
+                        e.printStackTrace();
+                    }
+                    continue;
+                }
+
+                LockSupport.parkNanos("FREE WAITING",1000000);
+            }
+            this.running = false;
+        }
+
+        public void start(){
+            this.running = true;
+            this.shouldRun = true;
+            this.worker.start();
+        }
+
+        @Nullable
+        private Runnable steal(){
+            long stamp = WorkStealingThreadPool.this.workersLock.tryOptimisticRead();
+            if (WorkStealingThreadPool.this.workersLock.validate(stamp)){
+                for (WorkerThread workerThread : WorkStealingThreadPool.this.workers){
+                    if (workerThread.equals(this)){
+                        continue;
+                    }
+                    if (workerThread.isCurrentThreadRunningTask() && workerThread.getQueuedTaskCount() >= 1){
+                        return workerThread.pollTask(true);
+                    }
+                }
+                return null;
+            }
+
+            stamp = WorkStealingThreadPool.this.workersLock.readLock();
+            try {
+                for (WorkerThread workerThread : WorkStealingThreadPool.this.workers){
+                    if (workerThread.equals(this)){
+                        continue;
+                    }
+                    if (workerThread.isCurrentThreadRunningTask() && workerThread.getQueuedTaskCount() >= 1){
+                        return workerThread.pollTask(true);
+                    }
+                }
+                return null;
+            }finally {
+                WorkStealingThreadPool.this.workersLock.unlockRead(stamp);
+            }
+        }
+
+
+        protected int getQueuedTaskCount(){
+            this.taskLock.readLock().lock();
+            try {
+                return this.tasks.size();
+            }finally {
+                this.taskLock.readLock().unlock();
+            }
+        }
+
+        protected boolean isCurrentThreadRunningTask(){
+            return this.runningTask.get();
+        }
+
+        @Nullable
+        protected Runnable pollTask(boolean tail){
+            Runnable polledRunnable;
+
+            this.taskLock.writeLock().lock();
+            try {
+                polledRunnable = tail ? this.tasks.pollLast() : this.tasks.pollFirst();
+            }finally {
+                this.taskLock.writeLock().unlock();
+            }
+
+            return polledRunnable;
+        }
+    }
+
+    public static class PackagedExecutor implements Executor{
+        private final WorkStealingThreadPool internalPool;
+
+        public PackagedExecutor(@NotNull WorkStealingThreadPool internalPool) {
+            this.internalPool = internalPool;
+        }
+
+        @Override
+        public void execute(@NotNull Runnable command) {
+            this.internalPool.postTask(command);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/co/earthme/hearse/server/ServerEntityTickHook.java b/src/main/java/co/earthme/hearse/server/ServerEntityTickHook.java
index b34e7432065f8101c1c4ad85e85cf932639f2b75..1896d163104236a618b659977045b18288f403c8 100644
--- a/src/main/java/co/earthme/hearse/server/ServerEntityTickHook.java
+++ b/src/main/java/co/earthme/hearse/server/ServerEntityTickHook.java
@@ -1,9 +1,8 @@
 package co.earthme.hearse.server;
 
-import co.earthme.hearse.Hearse;
 import co.earthme.hearse.HearseConfig;
+import co.earthme.hearse.concurrent.WorkStealingThreadPool;
 import co.earthme.hearse.concurrent.WorkerThreadFactory;
-import co.earthme.hearse.concurrent.WorkerThreadPoolExecutor;
 import co.earthme.hearse.concurrent.threadfactory.DefaultWorkerFactory;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
@@ -11,16 +10,15 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.player.Player;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
-import java.util.concurrent.LinkedBlockingQueue;
+
 import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.LockSupport;
 
 public class ServerEntityTickHook {
     private static final Logger logger = LogManager.getLogger();
     private static final WorkerThreadFactory defFactory = new DefaultWorkerFactory("entity");
-    private static WorkerThreadPoolExecutor worker;
+    private static WorkStealingThreadPool worker;
     private static boolean asyncEntityEnabled = true;
     private static boolean awaitEntityTasks = true;
     private static final AtomicInteger taskCounter = new AtomicInteger(0);
@@ -37,15 +35,10 @@ public class ServerEntityTickHook {
         awaitEntityTasks = HearseConfig.getBoolean("optimizations.await-parallel-entity-tasks",awaitEntityTasks);
         if (asyncEntityEnabled){
             final int workerCount = HearseConfig.getInt("workers.async-entity-worker-count",Runtime.getRuntime().availableProcessors());
-            worker = new WorkerThreadPoolExecutor(
-                    workerCount,
+            worker = new WorkStealingThreadPool(
                     workerCount,
-                    0L,
-                    TimeUnit.MILLISECONDS,
-                    new LinkedBlockingQueue<>(),
                     defFactory
             );
-            Hearse.getWorkerManager().addWorker("entity",worker);
         }
     }
 
@@ -81,7 +74,7 @@ public class ServerEntityTickHook {
             return;
         }
         try {
-            worker.execute(task);
+            worker.postTask(task);
         }catch (RejectedExecutionException e){
             logger.warn("Worker rejected our task.Falling back to sync entity updating");
             asyncEntityEnabled = false;
